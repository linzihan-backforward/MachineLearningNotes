# 目标检测（Object Detection）
***

### 目标定位
在这一节中我们不只是希望识别出图片中物体的类型，而是希望同时识别出物体的位置，然后用一个框将物体框出来，我们用4个数字来表示一个框，如果将图片的左上角设为（0，0）右下角设为（1，1）的话，我们就可以用一个坐标（bx,by）代表框的中心点，然后用bh代表框的宽度，bw代表框的高度，这样就用4个0到1之间的数字来表示了一个图片。
![](https://i.imgur.com/xDOMCHH.png)
然后我们对CNN的输出也要相应改变，假设我们现在希望对三种物体进行定位，那么我们就要输出一个8维的向量![](https://i.imgur.com/7NS9FAv.gif)其中pc代表图片中有没有出现要识别的物体，bx、by、bw、bh是上面说的识别框，c1、c2、c3是类似于softmax的说明物体是三类中哪一类的。如果图片中没有出现要识别物体，那么pc等于0，其余7个值为任意值，如果出现了，那么pc等于1，其余7个值才有意义。同样我们还可以输出物体的某些体征点，如人脸中一些特征或身体姿态特征等。现在我们已经知道了怎样来表示一个物体的位置，也知道了我们的CNN该输出怎样的信息，现在要做的就是怎么输出了。

***
### 滑动窗口算法

首先我们需要用一些物体，比如汽车、行人、摩托车的照片来训练一张传统的图片识别的网络，让这个网络能够对我们希望的物体输出1，而其他的输出0。然后我们首先设置一个很小的窗口，将这个小窗口对整个图片进行框取，注意每个框可能是有部分重叠的，然后将这个框内的图片传入刚才的网络，如果结果为1，则我们找到了物体，并且这个框就可能是物体的边界框，我们一直到遍历完整个图片，然后换用更大的框重新遍历，如果图片中有物体的话，我们这样是一定可以找到的。
但是第一个我们要考虑的问题就是运算量的问题。对于一个图片我们要跑很多次的前向传播，就导致速度很慢，可不可以对其并行计算呢？
答案是肯定的。在我们训练好的网络中，其每一层卷机器大小是固定的，接受固定大小的输入，最后才能保证输出是一个数，如果输入大了怎么办？我们发现其也可以完成前向传播，最后得到的就是一个矩阵而不是一个数，这个矩阵中每个数恰恰代表了用一个相应位置大小的输入得到的结果，也就是说最后的矩阵就是整张图片中哪里有物体的一张0、1分类表。这样就可以用一次前向传播得到整个滑动窗口算法的接过来。一张形象的图：
![](https://i.imgur.com/Dz3vFRK.png)
这个算法有一定的功能，但是其框选的准确度偏低，下面的算法会尝试改进。

***
### 交并比（IoU）

如何来评估我们算法形成的物体框的好坏呢？就要引入交并比的概念了。如果把物体标准的框和我们的框看成平面上两个方形的区域的话，这两个区域会形成一个交集和一个并集，交集与并集面积的比就定义为交并比。显然，如果两个区域重合的话，这个比应该为1，所以我们可以用交并比接近1的程度来衡量当前框的好坏，一般IoU大于0.5就认为是可以用的结果了。

### YOLO算法
现在我们尝试对上面的滑动窗口算法来一些改进。其中，在2015年提出了一个YOLO算法即You Only Look Once算法，其思路是将图片分成n×n的网格区域，在实践中n可能等于19，然后将每一个物体按照其中心点所在的位置让其属于这些网格区域中的一个，这时描述框的四个值变为了相对于其所属方格的值，注意其bw、bh可能会大于1，因为物体框可能超出方格区域，然后我们的输出也相应增多，如果分成19×19的格子的话最后的输出会变为19×19×8，每个格都有一个自己的判断结果。
如果仔细想想的话，这么做有可能出现对同一个物体的多个框，怎么取舍呢？就需要用到上边的交并比了。这种方法称为非极大值抑制。
其算法思想如下：
![](https://i.imgur.com/XxxPB4S.png)
首先找到每个方格输出的边界，去掉所有输出的可能性小于0.6的框，然后对于每个框找出其中可能性最大的那个，算出其余框与它的IoU，去掉所有IoU值大于0.6的框，然后重复这个步骤，直到遍历了所有框。

在YOLO算法中因为我们引入了每个物体属于一个小格的概念，以及输出可能性的方法，所以我们可以相对精确的输出物体的边框，这也是这个算法出彩的地方。

***

### Anchor Boxes

在上边的讨论中我们忽略了多个物体的中心位于同一个方格内的情况，尽管这种情况概率极低，但其也有可能出现，要解决这种情况只有增加我们的输出了。
引入Anchor Boxes的概念，我们让一个物体不只是属于一个方格，还让其属于一个Anchor Boxes，有几类物体就定义几个Anchor Boxes，其本质上就是为每一类物体定义一个单独的输出，如下面这样图中写的那样：
![](https://i.imgur.com/ljUySN7.png)
有两类物体需要检测，我们就让输出分为两部分，上边8个值是对于box1的，下边是box2的，这样就可以将在一个方格内的两个物体分开，如果再增加box也是同理。

这样我们就有了一个效果还不错的物体检测的算法，其表现究竟怎样呢？到代码里一探究竟吧！